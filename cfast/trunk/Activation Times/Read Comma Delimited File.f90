    subroutine readcsv (iunit,x,c,numr,numc,nstart,maxr,maxc)

    ! reads a comma-delimited file as generated by micorsoft excel. program assumes that all the data is in the form of real numbers

    ! variables:
    ! iunit  = logical unit, already open to .csv file
    ! x      = array of dimension (numr,numc) for values in spreadsheet
    ! c      = character array of same dimension as x for character values in spreadsheet
    ! numr   = # of rows of array x
    ! numc   = # of columns of array x
    ! nstart = starting row of spreadsheet to read
    ! nr     = actual number of rows read
    ! nc     = actual number of columns read

    implicit none 
    
    real x(numr,numc)
    integer :: maxr, maxc, i, j, nstart, iunit, nr, nc, ic, icomma, ios, numr, numc
    character in*50000,token*100, c(numr,numc)*(*)
    
    maxr = 0
    maxc = 0
    do i=1,numr
        do j=1,numc
            x(i,j) = 0.
            c(i,j) = ' '
        end do
    end do
    if (nstart.gt.1) then
        do  i=1,nstart-1
            read (iunit,'(a)') in
        end do 
    end if
    nr=0
20  read (iunit,'(a)',end=100) in
    nr=nr+1
    maxr=max(maxr,nr)
    nc=0
    ic=1
30  continue
    if (ic<=len_trim(in)) then
        call gettoken(in,ic,icomma,token)
        ic = icomma+1
        nc = nc + 1
        in(1:ic-1)=' '
        if (nr.le.numr.and.nc.le.numc) then
            c(nr,nc) = token
            if (token(1:1).eq.'"') then
                c(nr,nc)=token(2:len_trim(token)-1)
                token=c(nr,nc)
            end if
            if (len_trim(token).ne.0) then
                if (token(len_trim(token):len_trim(token)).eq.'"') c(nr,nc)=token(1:len_trim(token)-1)
            end if
            read (token,'(f100.0)',iostat=ios) x(nr,nc)
            if (ios.ne.0) x(nr,nc) = 0
        else
            write (*,*) 'array exceeded, r,c=',nr,nc
            stop
        end if
        go to 30
    end if
    nc = nc + 1
    maxc=max(maxc,nc)
    token = in(ic:ic+100)
    c(nr,nc) = token
    read (token,'(f100.0)',iostat=ios) x(nr,nc)
    if (ios.ne.0) x(nr,nc) = 0
    go to 20
100 continue
    return
    end subroutine readcsv
    
    subroutine gettoken(in,istart,iend,token)
    
    ! finds the next substring in an input line separated by commas.  If there are commas inside a quote string, these are ignored
    
    ! variables
    ! i            = string to be processed
    ! istart       = starting position in the string to be processed
    !iend (output) = position of the end of the substring 
    
    implicit none

    character in*(*), token*(*)
    integer istart, iend, i, icomma
    logical :: insideastring = .false.
    if (in(istart:istart)=='"') then
        do i = istart, len_trim(in)
            ! commas are allowed within character strings, so check for a quote that encloses character strings
            if (in(i:i)=='"') then
                if (insideastring) then
                    insideastring= .false.
                else
                    insideastring = .true.
                end if
                ! now we can look for commas and ignore them if they are within a quoted string
            else if (in(i:i)==',') then
                if (.not.insideastring) then
                    if (i==istart) then
                        token = " "
                    else
                        token = in(istart:i-1)
                    end if
                    iend = i
                    return
                end if
            end if
        end do
    else
        iend = index(in,",")
        if (iend==istart) then
            token = " "
            return
        else if (iend>=istart) then
            token = in(istart:iend-1)
            return
        end if
    end if
    token = in(istart:len_trim(in))
    iend = len_trim(in)
    return
    end