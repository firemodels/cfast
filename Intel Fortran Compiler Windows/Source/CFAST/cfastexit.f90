module exit_routines

    use precision_parameters
    
    use cparams, only: mx_dumps 
    use namelist_data, only: input_file_line, input_file_line_number
    use setup_data, only: validation_flag, iofilo, iofill, iofilstat, smv_out_interval, iofilsmv, iofilsmvplt, iofilsmvzone, &
        ss_out_interval, iofilssc, iofilssd, iofilssm, iofilssv, iofilssdiag, iofilcalc, stopfile, program_name, &
        errormessage, stime, project, extension
    use option_data, only: total_steps
    use dump_data, only: n_dumps, dumpinfo, csvnames, num_csvfiles, iocsv
    
    implicit none

    contains

    ! --------------------------- cfastexit -------------------------------------------

!> \brief   called when CFAST exits, printing an error code if necessary
!> \param   name        routine name calling for exit
!> \param   errorcode   numeric code indicating which call to cfastexit in routine

    subroutine cfastexit (name, errorcode)
    
    character(len=*), intent(in) :: name
    integer, intent(in) :: errorcode
    integer exitcode

    exitcode = errorcode
    if (errorcode/=0) call post_process
    if (errorcode/=0) then
        if (trim(name)=='solve_simulation' .and. errorcode==5) then
            ! validation flag test for the maximum iteration exit is because of CFASTBot's testing to make
            !   sure that CFAST can initialize and run a few steps of all the cases in debug mode but doesn't run
            !   to completion. DO NOT CHANGE WITHOUT CHANGING CFASTBOT.
            if (.not.validation_flag) write (*, '(''Maximum iteration exit from '',a)') program_name
            if (iofill/=0) write (iofill, '(''Maximum iteration exit from CFAST'',a)') program_name
            exitcode = 0
        else
            if (errormessage/='') write (*,'(a)') errormessage
            if (input_file_line/='') write (*,'(a,i0,a,a)') 'Error on line ',input_file_line_number, &
                ' of the input file: ', trim(input_file_line)
            write (*,'(''***Error exit from '',a,'', error '',i0,'' from routine '',a)') program_name, exitcode, trim(name)
            if (iofill/=0) then
                if (errormessage/='') write (*,'(a)') errormessage
                if (input_file_line/='') write (iofill,'(a,i0,a,a)') 'Error on line ',input_file_line_number, &
                    ' of the input file: ', trim(input_file_line)
                write (iofill,'(''***Error exit from '',a,'', error '',i0,'' from routine '',a)') program_name, &
                exitcode, trim(name)
            end if
        end if
    else
        if (.not.validation_flag) write (*, '(''Normal exit from '',a)') program_name
        if (iofill/=0) write (iofill, '(''Normal exit from '',a)') program_name
    end if
    
    call closeoutputfiles
    call delete_output_files (stopfile)
    
    if (exitcode==0) then
        stop
    else
        error stop 1
    end if
    stop
    
    contains 
    
    subroutine post_process
    
    integer, parameter :: nr = 2, ipad = 5, nc = mx_dumps + ipad
    real(eb) :: dumparray(nr, nc)
    character(len=128) :: dumpcarray(nr, nc)
    integer :: i, icount, mxcol
    
    if (n_dumps<=0) return
    dumparray(1, 1:nc) = 0
    dumparray(2, 2:nc) = -1001
    dumpcarray(1:nr, 2:nc) = 'NO VALUE ASSIGNED'
    dumparray(2,1) = 0
    dumpcarray(1,1) = 'File Name'
    dumpcarray(2,1) = trim(project) // trim(extension)
    dumpcarray(1,2) = 'Exit Code'
    dumparray(2,2) = errorcode
    dumpcarray(2,2) = '0'
    dumpcarray(1,3) = 'Exit Routine'
    dumpcarray(2,3) = trim(name)
    dumparray(2,3) = 0
    dumpcarray(1,4) = 'Simulation Time Completed'
    dumparray(2,4) = stime
    dumpcarray(1,5) = 'Total Steps Completed'
    dumparray(2,5) = total_steps
    
    do i = 1, n_dumps
        dumpcarray(1, ipad + i) = trim(dumpinfo(i)%id)
    end do
    mxcol = ipad+n_dumps
    call writecsvformat(iofilcalc, dumparray, dumpcarray, nr, nc, 1, 2, mxcol)
    return
    end subroutine post_process
    
    !   copied from outputspreadsheet because of make problems trying to 
    !       include outputspreadsheet in cfastexit. A better solution should be
    !       found. 
    
    subroutine writecsvformat (iunit, x, c, nr, nc, nstart, mxr, mxc)

    !     routine: writecsvformat
    !     purpose:writess a comma-delimited file as generated by Micorsoft Excel, assuming that all
    !              the data is in the form of real numbers
    !     arguments: iunit  = logical unit, already open to .csv file
    !                x      = array of dimension (numr,numc) for values in spreadsheet
    !                c      = character array of same dimenaion as x for character values in spreadsheet
    !                nr     = # of rows of arrays x and c
    !                nc     = # of columns of arrays x and c
    !                nstart = starting row of spreadsheet to read
    !                mxr    = actual number of rows read
    !                mxc    = actual number of columns read
    
    integer, intent(in) :: iunit, nr, nc, nstart, mxr, mxc

    real(eb), intent(in) :: x(nr,nc)
    character(len=*), intent(inout) :: c(nr,nc)

    character(len=204800) :: buf
    integer :: i, j, ic, ie
    
    do i = nstart, mxr
        buf = '                    '
        ic = 1
        do j = 1, mxc
            if (x(i,j) /= 0.0) then
                write(c(i,j),'(e16.9)') x(i,j)
            end if
            ie = ic + len_trim(c(i,j))
            buf(ic:ie) = trim(c(i,j))
            ic = ie+1
            buf(ic:ic) = ','
            ic = ic+1
        end do
        write(iunit,'(A)') buf(1:ic)
    end do
    
    return
    end subroutine writecsvformat
    
    !call output_spreadsheet_dump (name, errorcode, stime, total_steps)
    
    end subroutine cfastexit

! --------------------------- delete_output_files -------------------------------------------

    subroutine delete_output_files (outputfile)

    character(len=*), intent(in) :: outputfile
    integer :: fileunit, ios
    logical doesthefileexist

    inquire (file=outputfile, exist=doesthefileexist)
    if (DoesTheFileExist) then
        open (newunit=fileunit, iostat=ios, file=outputfile, status='old')
        if (ios==0) then
            close(fileunit, status='delete', iostat=ios)
            if (ios/=0) then
                write (errormessage,'(a,i0,a)') 'Error opening output file, returned status = ', ios, &
                    '. File may be in use by another application.'
                call cfastexit('delete_output_files',1)
            end if
        end if
    end if

    return
    end subroutine delete_output_files
    
    !---------------------closeoutputfiles------------------------------------------------------
    
    subroutine closeoutputfiles

    !	closeoutputfile closes units from open_output_files
    !	Unit numbers defined here and read_input_file

    !	Unit numbers defined for various I/O purposes
    !
    !     iofili        solver.ini and data files (data file, tpp and objects)
    !     iofill        log file
    !     iofilo        output 
    !     iofilstat     write the status file
    !     iofilsmv      smokeview output (header) - note this is rewound each time the plot data is written)
    !     iofilsmvplt   smokeview output (plot data)
    !     iofilsmvzone  smokeview spreadsheet output 
    !     iofilssc      spreadsheet output (compartment and layer related data)
    !     iofilsswd     spreadsheet output (measurement and trigger devices)
    !     iofilssm      spreadsheet output (layer masses)
    !     iofilssv      spreadsheet output (vent flows)
    !     iofilssdiag   spreadsheet output (various diagnostics for verification)
    !     ioresid       diagnostic file of solution vector
    !     ioslab        diagnostic file of flow slabs
    !     iofilcalc     spredsheet output (for monte carlo analysis)
    
    ! other units may be opened with newunit keyword in open statement
    
    logical :: openunit

    ! first the file for "printed" output
    inquire (iofilo, opened=openunit)
    if(openunit) then
        close(iofilo)
    end if

    ! the status files
    inquire (iofilstat, opened=openunit)
    if(openunit) then
        close(iofilstat)
    end if

    ! the smokeview files
    if (smv_out_interval>0) then
        inquire(iofilsmv, opened=openunit)
        if (openunit) then
            close(iofilsmv)
        end if
        inquire(iofilsmvplt, opened=openunit)
        if (openunit) then
            close(iofilsmvplt)
        end if
        inquire(iofilsmvzone, opened=openunit)
        if (openunit) then
            close(iofilsmvzone)
        end if
    end if

    ! the spread sheet files
    if (ss_out_interval>0) then
        ! compartments spreadsheet
        inquire(iofilssc, opened=openunit)
        if(openunit) then
            close(iofilssc)
        end if
        ! devices spreadsheet
        inquire(iofilssd, opened=openunit)
        if (openunit) then
            close(iofilssd)
        end if
        ! masses spreadsheet
        inquire(iofilssm, opened=openunit)
        if (openunit) then
            close(iofilssm)
        end if
        ! vents spreadsheet
        inquire(iofilssv, opened=openunit)
        if (openunit) then 
            close(iofilssv)
        end if
        ! diagnostic spreadsheet
        inquire(iofilssdiag, opened=openunit)
        if (openunit) then
            close(iofilssdiag)
        end if
        ! calculations spreadhseet
        inquire(iofilcalc, opened=openunit)
        if (openunit) then
            close(iofilcalc)
        end if
    end if 
    
    end subroutine closeoutputfiles
    
end module exit_routines